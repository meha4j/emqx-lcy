//------------------------------------------------------------------------------
// Copyright (c) 2020-2024 EMQ Technologies Co., Ltd. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//------------------------------------------------------------------------------

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.28.3
// source: internal/api/exproto.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ConnectionAdapter_Send_FullMethodName         = "/emqx.exproto.v1.ConnectionAdapter/Send"
	ConnectionAdapter_Close_FullMethodName        = "/emqx.exproto.v1.ConnectionAdapter/Close"
	ConnectionAdapter_Authenticate_FullMethodName = "/emqx.exproto.v1.ConnectionAdapter/Authenticate"
	ConnectionAdapter_StartTimer_FullMethodName   = "/emqx.exproto.v1.ConnectionAdapter/StartTimer"
	ConnectionAdapter_Publish_FullMethodName      = "/emqx.exproto.v1.ConnectionAdapter/Publish"
	ConnectionAdapter_Subscribe_FullMethodName    = "/emqx.exproto.v1.ConnectionAdapter/Subscribe"
	ConnectionAdapter_Unsubscribe_FullMethodName  = "/emqx.exproto.v1.ConnectionAdapter/Unsubscribe"
	ConnectionAdapter_RawPublish_FullMethodName   = "/emqx.exproto.v1.ConnectionAdapter/RawPublish"
)

// ConnectionAdapterClient is the client API for ConnectionAdapter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// The Broker side service. It provides a set of APIs to
// handle a protocol access
type ConnectionAdapterClient interface {
	Send(ctx context.Context, in *SendBytesRequest, opts ...grpc.CallOption) (*CodeResponse, error)
	Close(ctx context.Context, in *CloseSocketRequest, opts ...grpc.CallOption) (*CodeResponse, error)
	Authenticate(ctx context.Context, in *AuthenticateRequest, opts ...grpc.CallOption) (*CodeResponse, error)
	StartTimer(ctx context.Context, in *TimerRequest, opts ...grpc.CallOption) (*CodeResponse, error)
	Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*CodeResponse, error)
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*CodeResponse, error)
	Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*CodeResponse, error)
	RawPublish(ctx context.Context, in *RawPublishRequest, opts ...grpc.CallOption) (*CodeResponse, error)
}

type connectionAdapterClient struct {
	cc grpc.ClientConnInterface
}

func NewConnectionAdapterClient(cc grpc.ClientConnInterface) ConnectionAdapterClient {
	return &connectionAdapterClient{cc}
}

func (c *connectionAdapterClient) Send(ctx context.Context, in *SendBytesRequest, opts ...grpc.CallOption) (*CodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CodeResponse)
	err := c.cc.Invoke(ctx, ConnectionAdapter_Send_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectionAdapterClient) Close(ctx context.Context, in *CloseSocketRequest, opts ...grpc.CallOption) (*CodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CodeResponse)
	err := c.cc.Invoke(ctx, ConnectionAdapter_Close_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectionAdapterClient) Authenticate(ctx context.Context, in *AuthenticateRequest, opts ...grpc.CallOption) (*CodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CodeResponse)
	err := c.cc.Invoke(ctx, ConnectionAdapter_Authenticate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectionAdapterClient) StartTimer(ctx context.Context, in *TimerRequest, opts ...grpc.CallOption) (*CodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CodeResponse)
	err := c.cc.Invoke(ctx, ConnectionAdapter_StartTimer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectionAdapterClient) Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*CodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CodeResponse)
	err := c.cc.Invoke(ctx, ConnectionAdapter_Publish_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectionAdapterClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*CodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CodeResponse)
	err := c.cc.Invoke(ctx, ConnectionAdapter_Subscribe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectionAdapterClient) Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*CodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CodeResponse)
	err := c.cc.Invoke(ctx, ConnectionAdapter_Unsubscribe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectionAdapterClient) RawPublish(ctx context.Context, in *RawPublishRequest, opts ...grpc.CallOption) (*CodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CodeResponse)
	err := c.cc.Invoke(ctx, ConnectionAdapter_RawPublish_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConnectionAdapterServer is the server API for ConnectionAdapter service.
// All implementations must embed UnimplementedConnectionAdapterServer
// for forward compatibility.
//
// The Broker side service. It provides a set of APIs to
// handle a protocol access
type ConnectionAdapterServer interface {
	Send(context.Context, *SendBytesRequest) (*CodeResponse, error)
	Close(context.Context, *CloseSocketRequest) (*CodeResponse, error)
	Authenticate(context.Context, *AuthenticateRequest) (*CodeResponse, error)
	StartTimer(context.Context, *TimerRequest) (*CodeResponse, error)
	Publish(context.Context, *PublishRequest) (*CodeResponse, error)
	Subscribe(context.Context, *SubscribeRequest) (*CodeResponse, error)
	Unsubscribe(context.Context, *UnsubscribeRequest) (*CodeResponse, error)
	RawPublish(context.Context, *RawPublishRequest) (*CodeResponse, error)
	mustEmbedUnimplementedConnectionAdapterServer()
}

// UnimplementedConnectionAdapterServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConnectionAdapterServer struct{}

func (UnimplementedConnectionAdapterServer) Send(context.Context, *SendBytesRequest) (*CodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedConnectionAdapterServer) Close(context.Context, *CloseSocketRequest) (*CodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Close not implemented")
}
func (UnimplementedConnectionAdapterServer) Authenticate(context.Context, *AuthenticateRequest) (*CodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Authenticate not implemented")
}
func (UnimplementedConnectionAdapterServer) StartTimer(context.Context, *TimerRequest) (*CodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartTimer not implemented")
}
func (UnimplementedConnectionAdapterServer) Publish(context.Context, *PublishRequest) (*CodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Publish not implemented")
}
func (UnimplementedConnectionAdapterServer) Subscribe(context.Context, *SubscribeRequest) (*CodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedConnectionAdapterServer) Unsubscribe(context.Context, *UnsubscribeRequest) (*CodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unsubscribe not implemented")
}
func (UnimplementedConnectionAdapterServer) RawPublish(context.Context, *RawPublishRequest) (*CodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RawPublish not implemented")
}
func (UnimplementedConnectionAdapterServer) mustEmbedUnimplementedConnectionAdapterServer() {}
func (UnimplementedConnectionAdapterServer) testEmbeddedByValue()                           {}

// UnsafeConnectionAdapterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConnectionAdapterServer will
// result in compilation errors.
type UnsafeConnectionAdapterServer interface {
	mustEmbedUnimplementedConnectionAdapterServer()
}

func RegisterConnectionAdapterServer(s grpc.ServiceRegistrar, srv ConnectionAdapterServer) {
	// If the following call pancis, it indicates UnimplementedConnectionAdapterServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConnectionAdapter_ServiceDesc, srv)
}

func _ConnectionAdapter_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendBytesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionAdapterServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConnectionAdapter_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionAdapterServer).Send(ctx, req.(*SendBytesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConnectionAdapter_Close_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseSocketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionAdapterServer).Close(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConnectionAdapter_Close_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionAdapterServer).Close(ctx, req.(*CloseSocketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConnectionAdapter_Authenticate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthenticateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionAdapterServer).Authenticate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConnectionAdapter_Authenticate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionAdapterServer).Authenticate(ctx, req.(*AuthenticateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConnectionAdapter_StartTimer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TimerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionAdapterServer).StartTimer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConnectionAdapter_StartTimer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionAdapterServer).StartTimer(ctx, req.(*TimerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConnectionAdapter_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionAdapterServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConnectionAdapter_Publish_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionAdapterServer).Publish(ctx, req.(*PublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConnectionAdapter_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionAdapterServer).Subscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConnectionAdapter_Subscribe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionAdapterServer).Subscribe(ctx, req.(*SubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConnectionAdapter_Unsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionAdapterServer).Unsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConnectionAdapter_Unsubscribe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionAdapterServer).Unsubscribe(ctx, req.(*UnsubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConnectionAdapter_RawPublish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RawPublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionAdapterServer).RawPublish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConnectionAdapter_RawPublish_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionAdapterServer).RawPublish(ctx, req.(*RawPublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ConnectionAdapter_ServiceDesc is the grpc.ServiceDesc for ConnectionAdapter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConnectionAdapter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "emqx.exproto.v1.ConnectionAdapter",
	HandlerType: (*ConnectionAdapterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _ConnectionAdapter_Send_Handler,
		},
		{
			MethodName: "Close",
			Handler:    _ConnectionAdapter_Close_Handler,
		},
		{
			MethodName: "Authenticate",
			Handler:    _ConnectionAdapter_Authenticate_Handler,
		},
		{
			MethodName: "StartTimer",
			Handler:    _ConnectionAdapter_StartTimer_Handler,
		},
		{
			MethodName: "Publish",
			Handler:    _ConnectionAdapter_Publish_Handler,
		},
		{
			MethodName: "Subscribe",
			Handler:    _ConnectionAdapter_Subscribe_Handler,
		},
		{
			MethodName: "Unsubscribe",
			Handler:    _ConnectionAdapter_Unsubscribe_Handler,
		},
		{
			MethodName: "RawPublish",
			Handler:    _ConnectionAdapter_RawPublish_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/api/exproto.proto",
}

const (
	ConnectionHandler_OnSocketCreated_FullMethodName    = "/emqx.exproto.v1.ConnectionHandler/OnSocketCreated"
	ConnectionHandler_OnSocketClosed_FullMethodName     = "/emqx.exproto.v1.ConnectionHandler/OnSocketClosed"
	ConnectionHandler_OnReceivedBytes_FullMethodName    = "/emqx.exproto.v1.ConnectionHandler/OnReceivedBytes"
	ConnectionHandler_OnTimerTimeout_FullMethodName     = "/emqx.exproto.v1.ConnectionHandler/OnTimerTimeout"
	ConnectionHandler_OnReceivedMessages_FullMethodName = "/emqx.exproto.v1.ConnectionHandler/OnReceivedMessages"
)

// ConnectionHandlerClient is the client API for ConnectionHandler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Deprecated service.
// Please using `ConnectionUnaryHandler` to replace it
type ConnectionHandlerClient interface {
	OnSocketCreated(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[SocketCreatedRequest, EmptySuccess], error)
	OnSocketClosed(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[SocketClosedRequest, EmptySuccess], error)
	OnReceivedBytes(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[ReceivedBytesRequest, EmptySuccess], error)
	OnTimerTimeout(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[TimerTimeoutRequest, EmptySuccess], error)
	OnReceivedMessages(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[ReceivedMessagesRequest, EmptySuccess], error)
}

type connectionHandlerClient struct {
	cc grpc.ClientConnInterface
}

func NewConnectionHandlerClient(cc grpc.ClientConnInterface) ConnectionHandlerClient {
	return &connectionHandlerClient{cc}
}

func (c *connectionHandlerClient) OnSocketCreated(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[SocketCreatedRequest, EmptySuccess], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ConnectionHandler_ServiceDesc.Streams[0], ConnectionHandler_OnSocketCreated_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SocketCreatedRequest, EmptySuccess]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ConnectionHandler_OnSocketCreatedClient = grpc.ClientStreamingClient[SocketCreatedRequest, EmptySuccess]

func (c *connectionHandlerClient) OnSocketClosed(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[SocketClosedRequest, EmptySuccess], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ConnectionHandler_ServiceDesc.Streams[1], ConnectionHandler_OnSocketClosed_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SocketClosedRequest, EmptySuccess]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ConnectionHandler_OnSocketClosedClient = grpc.ClientStreamingClient[SocketClosedRequest, EmptySuccess]

func (c *connectionHandlerClient) OnReceivedBytes(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[ReceivedBytesRequest, EmptySuccess], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ConnectionHandler_ServiceDesc.Streams[2], ConnectionHandler_OnReceivedBytes_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ReceivedBytesRequest, EmptySuccess]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ConnectionHandler_OnReceivedBytesClient = grpc.ClientStreamingClient[ReceivedBytesRequest, EmptySuccess]

func (c *connectionHandlerClient) OnTimerTimeout(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[TimerTimeoutRequest, EmptySuccess], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ConnectionHandler_ServiceDesc.Streams[3], ConnectionHandler_OnTimerTimeout_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TimerTimeoutRequest, EmptySuccess]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ConnectionHandler_OnTimerTimeoutClient = grpc.ClientStreamingClient[TimerTimeoutRequest, EmptySuccess]

func (c *connectionHandlerClient) OnReceivedMessages(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[ReceivedMessagesRequest, EmptySuccess], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ConnectionHandler_ServiceDesc.Streams[4], ConnectionHandler_OnReceivedMessages_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ReceivedMessagesRequest, EmptySuccess]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ConnectionHandler_OnReceivedMessagesClient = grpc.ClientStreamingClient[ReceivedMessagesRequest, EmptySuccess]

// ConnectionHandlerServer is the server API for ConnectionHandler service.
// All implementations must embed UnimplementedConnectionHandlerServer
// for forward compatibility.
//
// Deprecated service.
// Please using `ConnectionUnaryHandler` to replace it
type ConnectionHandlerServer interface {
	OnSocketCreated(grpc.ClientStreamingServer[SocketCreatedRequest, EmptySuccess]) error
	OnSocketClosed(grpc.ClientStreamingServer[SocketClosedRequest, EmptySuccess]) error
	OnReceivedBytes(grpc.ClientStreamingServer[ReceivedBytesRequest, EmptySuccess]) error
	OnTimerTimeout(grpc.ClientStreamingServer[TimerTimeoutRequest, EmptySuccess]) error
	OnReceivedMessages(grpc.ClientStreamingServer[ReceivedMessagesRequest, EmptySuccess]) error
	mustEmbedUnimplementedConnectionHandlerServer()
}

// UnimplementedConnectionHandlerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConnectionHandlerServer struct{}

func (UnimplementedConnectionHandlerServer) OnSocketCreated(grpc.ClientStreamingServer[SocketCreatedRequest, EmptySuccess]) error {
	return status.Errorf(codes.Unimplemented, "method OnSocketCreated not implemented")
}
func (UnimplementedConnectionHandlerServer) OnSocketClosed(grpc.ClientStreamingServer[SocketClosedRequest, EmptySuccess]) error {
	return status.Errorf(codes.Unimplemented, "method OnSocketClosed not implemented")
}
func (UnimplementedConnectionHandlerServer) OnReceivedBytes(grpc.ClientStreamingServer[ReceivedBytesRequest, EmptySuccess]) error {
	return status.Errorf(codes.Unimplemented, "method OnReceivedBytes not implemented")
}
func (UnimplementedConnectionHandlerServer) OnTimerTimeout(grpc.ClientStreamingServer[TimerTimeoutRequest, EmptySuccess]) error {
	return status.Errorf(codes.Unimplemented, "method OnTimerTimeout not implemented")
}
func (UnimplementedConnectionHandlerServer) OnReceivedMessages(grpc.ClientStreamingServer[ReceivedMessagesRequest, EmptySuccess]) error {
	return status.Errorf(codes.Unimplemented, "method OnReceivedMessages not implemented")
}
func (UnimplementedConnectionHandlerServer) mustEmbedUnimplementedConnectionHandlerServer() {}
func (UnimplementedConnectionHandlerServer) testEmbeddedByValue()                           {}

// UnsafeConnectionHandlerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConnectionHandlerServer will
// result in compilation errors.
type UnsafeConnectionHandlerServer interface {
	mustEmbedUnimplementedConnectionHandlerServer()
}

func RegisterConnectionHandlerServer(s grpc.ServiceRegistrar, srv ConnectionHandlerServer) {
	// If the following call pancis, it indicates UnimplementedConnectionHandlerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConnectionHandler_ServiceDesc, srv)
}

func _ConnectionHandler_OnSocketCreated_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ConnectionHandlerServer).OnSocketCreated(&grpc.GenericServerStream[SocketCreatedRequest, EmptySuccess]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ConnectionHandler_OnSocketCreatedServer = grpc.ClientStreamingServer[SocketCreatedRequest, EmptySuccess]

func _ConnectionHandler_OnSocketClosed_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ConnectionHandlerServer).OnSocketClosed(&grpc.GenericServerStream[SocketClosedRequest, EmptySuccess]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ConnectionHandler_OnSocketClosedServer = grpc.ClientStreamingServer[SocketClosedRequest, EmptySuccess]

func _ConnectionHandler_OnReceivedBytes_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ConnectionHandlerServer).OnReceivedBytes(&grpc.GenericServerStream[ReceivedBytesRequest, EmptySuccess]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ConnectionHandler_OnReceivedBytesServer = grpc.ClientStreamingServer[ReceivedBytesRequest, EmptySuccess]

func _ConnectionHandler_OnTimerTimeout_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ConnectionHandlerServer).OnTimerTimeout(&grpc.GenericServerStream[TimerTimeoutRequest, EmptySuccess]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ConnectionHandler_OnTimerTimeoutServer = grpc.ClientStreamingServer[TimerTimeoutRequest, EmptySuccess]

func _ConnectionHandler_OnReceivedMessages_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ConnectionHandlerServer).OnReceivedMessages(&grpc.GenericServerStream[ReceivedMessagesRequest, EmptySuccess]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ConnectionHandler_OnReceivedMessagesServer = grpc.ClientStreamingServer[ReceivedMessagesRequest, EmptySuccess]

// ConnectionHandler_ServiceDesc is the grpc.ServiceDesc for ConnectionHandler service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConnectionHandler_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "emqx.exproto.v1.ConnectionHandler",
	HandlerType: (*ConnectionHandlerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "OnSocketCreated",
			Handler:       _ConnectionHandler_OnSocketCreated_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "OnSocketClosed",
			Handler:       _ConnectionHandler_OnSocketClosed_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "OnReceivedBytes",
			Handler:       _ConnectionHandler_OnReceivedBytes_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "OnTimerTimeout",
			Handler:       _ConnectionHandler_OnTimerTimeout_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "OnReceivedMessages",
			Handler:       _ConnectionHandler_OnReceivedMessages_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "internal/api/exproto.proto",
}

const (
	ConnectionUnaryHandler_OnSocketCreated_FullMethodName    = "/emqx.exproto.v1.ConnectionUnaryHandler/OnSocketCreated"
	ConnectionUnaryHandler_OnSocketClosed_FullMethodName     = "/emqx.exproto.v1.ConnectionUnaryHandler/OnSocketClosed"
	ConnectionUnaryHandler_OnReceivedBytes_FullMethodName    = "/emqx.exproto.v1.ConnectionUnaryHandler/OnReceivedBytes"
	ConnectionUnaryHandler_OnTimerTimeout_FullMethodName     = "/emqx.exproto.v1.ConnectionUnaryHandler/OnTimerTimeout"
	ConnectionUnaryHandler_OnReceivedMessages_FullMethodName = "/emqx.exproto.v1.ConnectionUnaryHandler/OnReceivedMessages"
)

// ConnectionUnaryHandlerClient is the client API for ConnectionUnaryHandler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// This service is an optimization of `ConnectionHandler`.
// In the initial version, we expected to use streams to improve the efficiency
// of requests. But unfortunately, events between different streams are out of
// order. it causes the `OnSocketCreated` event to may arrive later than `OnReceivedBytes`.
//
// So we added the `ConnectionUnaryHandler` service since v4.3.21/v4.4.10 and forced
// the use of Unary in it to avoid ordering problems.
//
// Recommend using `ConnectionUnaryHandler` to replace `ConnectionHandler`
type ConnectionUnaryHandlerClient interface {
	OnSocketCreated(ctx context.Context, in *SocketCreatedRequest, opts ...grpc.CallOption) (*EmptySuccess, error)
	OnSocketClosed(ctx context.Context, in *SocketClosedRequest, opts ...grpc.CallOption) (*EmptySuccess, error)
	OnReceivedBytes(ctx context.Context, in *ReceivedBytesRequest, opts ...grpc.CallOption) (*EmptySuccess, error)
	OnTimerTimeout(ctx context.Context, in *TimerTimeoutRequest, opts ...grpc.CallOption) (*EmptySuccess, error)
	OnReceivedMessages(ctx context.Context, in *ReceivedMessagesRequest, opts ...grpc.CallOption) (*EmptySuccess, error)
}

type connectionUnaryHandlerClient struct {
	cc grpc.ClientConnInterface
}

func NewConnectionUnaryHandlerClient(cc grpc.ClientConnInterface) ConnectionUnaryHandlerClient {
	return &connectionUnaryHandlerClient{cc}
}

func (c *connectionUnaryHandlerClient) OnSocketCreated(ctx context.Context, in *SocketCreatedRequest, opts ...grpc.CallOption) (*EmptySuccess, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptySuccess)
	err := c.cc.Invoke(ctx, ConnectionUnaryHandler_OnSocketCreated_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectionUnaryHandlerClient) OnSocketClosed(ctx context.Context, in *SocketClosedRequest, opts ...grpc.CallOption) (*EmptySuccess, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptySuccess)
	err := c.cc.Invoke(ctx, ConnectionUnaryHandler_OnSocketClosed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectionUnaryHandlerClient) OnReceivedBytes(ctx context.Context, in *ReceivedBytesRequest, opts ...grpc.CallOption) (*EmptySuccess, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptySuccess)
	err := c.cc.Invoke(ctx, ConnectionUnaryHandler_OnReceivedBytes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectionUnaryHandlerClient) OnTimerTimeout(ctx context.Context, in *TimerTimeoutRequest, opts ...grpc.CallOption) (*EmptySuccess, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptySuccess)
	err := c.cc.Invoke(ctx, ConnectionUnaryHandler_OnTimerTimeout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectionUnaryHandlerClient) OnReceivedMessages(ctx context.Context, in *ReceivedMessagesRequest, opts ...grpc.CallOption) (*EmptySuccess, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptySuccess)
	err := c.cc.Invoke(ctx, ConnectionUnaryHandler_OnReceivedMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConnectionUnaryHandlerServer is the server API for ConnectionUnaryHandler service.
// All implementations must embed UnimplementedConnectionUnaryHandlerServer
// for forward compatibility.
//
// This service is an optimization of `ConnectionHandler`.
// In the initial version, we expected to use streams to improve the efficiency
// of requests. But unfortunately, events between different streams are out of
// order. it causes the `OnSocketCreated` event to may arrive later than `OnReceivedBytes`.
//
// So we added the `ConnectionUnaryHandler` service since v4.3.21/v4.4.10 and forced
// the use of Unary in it to avoid ordering problems.
//
// Recommend using `ConnectionUnaryHandler` to replace `ConnectionHandler`
type ConnectionUnaryHandlerServer interface {
	OnSocketCreated(context.Context, *SocketCreatedRequest) (*EmptySuccess, error)
	OnSocketClosed(context.Context, *SocketClosedRequest) (*EmptySuccess, error)
	OnReceivedBytes(context.Context, *ReceivedBytesRequest) (*EmptySuccess, error)
	OnTimerTimeout(context.Context, *TimerTimeoutRequest) (*EmptySuccess, error)
	OnReceivedMessages(context.Context, *ReceivedMessagesRequest) (*EmptySuccess, error)
	mustEmbedUnimplementedConnectionUnaryHandlerServer()
}

// UnimplementedConnectionUnaryHandlerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConnectionUnaryHandlerServer struct{}

func (UnimplementedConnectionUnaryHandlerServer) OnSocketCreated(context.Context, *SocketCreatedRequest) (*EmptySuccess, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnSocketCreated not implemented")
}
func (UnimplementedConnectionUnaryHandlerServer) OnSocketClosed(context.Context, *SocketClosedRequest) (*EmptySuccess, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnSocketClosed not implemented")
}
func (UnimplementedConnectionUnaryHandlerServer) OnReceivedBytes(context.Context, *ReceivedBytesRequest) (*EmptySuccess, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnReceivedBytes not implemented")
}
func (UnimplementedConnectionUnaryHandlerServer) OnTimerTimeout(context.Context, *TimerTimeoutRequest) (*EmptySuccess, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnTimerTimeout not implemented")
}
func (UnimplementedConnectionUnaryHandlerServer) OnReceivedMessages(context.Context, *ReceivedMessagesRequest) (*EmptySuccess, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnReceivedMessages not implemented")
}
func (UnimplementedConnectionUnaryHandlerServer) mustEmbedUnimplementedConnectionUnaryHandlerServer() {
}
func (UnimplementedConnectionUnaryHandlerServer) testEmbeddedByValue() {}

// UnsafeConnectionUnaryHandlerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConnectionUnaryHandlerServer will
// result in compilation errors.
type UnsafeConnectionUnaryHandlerServer interface {
	mustEmbedUnimplementedConnectionUnaryHandlerServer()
}

func RegisterConnectionUnaryHandlerServer(s grpc.ServiceRegistrar, srv ConnectionUnaryHandlerServer) {
	// If the following call pancis, it indicates UnimplementedConnectionUnaryHandlerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConnectionUnaryHandler_ServiceDesc, srv)
}

func _ConnectionUnaryHandler_OnSocketCreated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SocketCreatedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionUnaryHandlerServer).OnSocketCreated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConnectionUnaryHandler_OnSocketCreated_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionUnaryHandlerServer).OnSocketCreated(ctx, req.(*SocketCreatedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConnectionUnaryHandler_OnSocketClosed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SocketClosedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionUnaryHandlerServer).OnSocketClosed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConnectionUnaryHandler_OnSocketClosed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionUnaryHandlerServer).OnSocketClosed(ctx, req.(*SocketClosedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConnectionUnaryHandler_OnReceivedBytes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReceivedBytesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionUnaryHandlerServer).OnReceivedBytes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConnectionUnaryHandler_OnReceivedBytes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionUnaryHandlerServer).OnReceivedBytes(ctx, req.(*ReceivedBytesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConnectionUnaryHandler_OnTimerTimeout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TimerTimeoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionUnaryHandlerServer).OnTimerTimeout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConnectionUnaryHandler_OnTimerTimeout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionUnaryHandlerServer).OnTimerTimeout(ctx, req.(*TimerTimeoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConnectionUnaryHandler_OnReceivedMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReceivedMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionUnaryHandlerServer).OnReceivedMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConnectionUnaryHandler_OnReceivedMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionUnaryHandlerServer).OnReceivedMessages(ctx, req.(*ReceivedMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ConnectionUnaryHandler_ServiceDesc is the grpc.ServiceDesc for ConnectionUnaryHandler service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConnectionUnaryHandler_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "emqx.exproto.v1.ConnectionUnaryHandler",
	HandlerType: (*ConnectionUnaryHandlerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnSocketCreated",
			Handler:    _ConnectionUnaryHandler_OnSocketCreated_Handler,
		},
		{
			MethodName: "OnSocketClosed",
			Handler:    _ConnectionUnaryHandler_OnSocketClosed_Handler,
		},
		{
			MethodName: "OnReceivedBytes",
			Handler:    _ConnectionUnaryHandler_OnReceivedBytes_Handler,
		},
		{
			MethodName: "OnTimerTimeout",
			Handler:    _ConnectionUnaryHandler_OnTimerTimeout_Handler,
		},
		{
			MethodName: "OnReceivedMessages",
			Handler:    _ConnectionUnaryHandler_OnReceivedMessages_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/api/exproto.proto",
}
